<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[native crash相关小结]]></title>
      <url>%2F2017%2F08%2F01%2Fnative%20crash%E7%9B%B8%E5%85%B3%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[小结一下native crash捕获的原理以及常用的查看crash堆栈方法。附录为常见的ndk相关命令。 ¶一、native crash捕获原理 native crash捕获的原理摘选完善自:Android 开发中常见 Crash 的情况。native crash捕获主要利用了Linux的信号机制(进程间通信方式的一种)。当应用程序异常，Linux内核将产生的错误信息通知当前进程。当前进程在接收到该错误信号后，可以有三种不同的处理方式。 (1)忽略该信号。 (2)捕捉该信号并执行对应的信号处理函数(signal handler)。 (3)执行该信号的缺省操作(如 SIGSEGV， 其缺省操作是终止进程)。 当 Linux 应用程序在执行时发生严重错误，一般会导致程序 crash。其中，Linux 专门提供了一类 crash 信号，在程序接收到此类信号时，缺省操作是将 crash 的现场信息记录到 core 文件，然后终止进程。 Android Native程序本质上就是一个Linux程序，在执行时发生错误程序crash之后，也会产生一个记录crash现场信息的文件，在Android系统中就是tombstone文件，这个文件保存在路径/data/tombstones/目录下，以tombstone_数字编号命名。 参见下面这个tombstone文件，是我从data/tombstones/目录下拷贝出来的tombstone_00文件，可以看到此文件记录了死亡进程的基本信息(比如进程的进程号(pid)、线程号(tid))，死亡的地址，死亡现场的堆栈调用信息等: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Build fingerprint: &apos;Android/rk3288/rk3288:5.1.1/LMY49F/elc-liubei06091434:userdebug/test-keys&apos;Revision: &apos;0&apos;ABI: &apos;arm&apos;pid: 25243, tid: 25260, name: Binder_2 &gt;&gt;&gt; com.tencent.daemon &lt;&lt;&lt;signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x14 r0 00000000 r1 a1c47c02 r2 a1c47c08 r3 a2180820 r4 00000000 r5 72da7878 r6 00000006 r7 a1c47c08 r8 12e01660 r9 b72e3cd0 sl 12e09aa0 fp 12e09b20 ip b520d450 sp a21807b0 lr a1c0e1db pc a1b85be0 cpsr 200d0030 d0 65742e6d6f632330 d1 616d2e746e656330 d2 3036314070706130 d3 3030313031303031 d4 7674710e0cf77572 d5 75f677890bf50ff6 d6 52b34d2a4aaa02e1 d7 71b31cc653c98a50 d8 0000000000000000 d9 0000000000000000 d10 0000000000000000 d11 0000000000000000 d12 0000000000000000 d13 0000000000000000 d14 0000000000000000 d15 0000000000000000 d16 0000000000000000 d17 4020000000000000 d18 4024000000000000 d19 72dd989072dd9858 d20 72dd974072dd9708 d21 4020000000000000 d22 6f6181706f618170 d23 72dd96d072dd9698 d24 6f6181706f618170 d25 6f6181706f618170 d26 6f6181706f618170 d27 6f6181706f618170 d28 6f6181706f618170 d29 6f6181706f618170 d30 6f6181706f618170 d31 4000000000000000 scr 80000011backtrace: #00 pc 0007ebe0 /data/app/com.tencent.daemon-1/lib/arm/libhwnetcore.so (std::string::_M_assign(char const*, char const*)+7) #01 pc 001071d7 /data/app/com.tencent.daemon-1/lib/arm/libhwnetcore.so (Java_com_tencent_wechat_HWNetcore_addCommonRequest+30) #02 pc 001e0e79 /data/dalvik-cache/arm/data@app@com.tencent.daemon-1@base.apk@classes.dex stack: a2180770 b520c9b8 /system/lib/libart.so a2180774 00000030 a2180778 b72e3cd0 [heap] a218077c b45fbe0e a2180780 b72f0628 [heap] a2180784 b510e895 /system/lib/libart.so (art::JNI::ReleaseByteArrayElements(_JNIEnv*, _jbyteArray*, signed char*, int)) a2180788 b72e4310 [heap] a218078c a21807cc [stack:25260] a2180790 a2180820 [stack:25260] a2180794 12e01660 /dev/ashmem/dalvik-main space (deleted) ``` ### tombstone文件主要的组成部分: (1) Build fingerprint (2) ABI(Application binary interface):应用程序二进制接口，定义了一套规则，允许编译好的二进制目标代码在所有兼容该ABI的操作系统和硬件平台中无需改动就能运行。而具体的实现是由编译器、CPU和操作系统共同完成的。不同的CPU芯片(如ARM、Intel x86等)支持不同的ABI架构，常见的ABI类型包括:armeabi,armeabi-v7a,x86,x64,mips。从tombstone文件可看出ABI为ARM类型 (3) pid(进程号)和tid(线程号)，如果pid和tid相同，则在主线程中crash，name里面则是进程名 pid: 25243, tid: 25260, name: Binder_2 &gt;&gt;&gt; com.tencent.daemon &lt;&lt;&lt; 12345678910 (4) Terminated signal and fault address信息可以看到是signal 11导致的crash,访问了非法的地址0x4 ``` signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x14``` Android中信号量如下所示,只有signal 9可以无条件终止进程: adb shell kill -l 1 HUP Hangup 33 33 Signal 33 2 INT Interrupt 34 34 Signal 34 3 QUIT Quit 35 35 Signal 35 4 ILL Illegal instruction 36 36 Signal 36 5 TRAP Trap 37 37 Signal 37 6 ABRT Aborted 38 38 Signal 38 7 BUS Bus error 39 39 Signal 39 8 FPE Floating point exception 40 40 Signal 40 9 KILL Killed 41 41 Signal 41 10 USR1 User signal 1 42 42 Signal 42 11 SEGV Segmentation fault 43 43 Signal 43 12 USR2 User signal 2 44 44 Signal 44 13 PIPE Broken pipe 45 45 Signal 45 14 ALRM Alarm clock 46 46 Signal 46 15 TERM Terminated 47 47 Signal 47 16 STKFLT Stack fault 48 48 Signal 48 17 CHLD Child exited 49 49 Signal 49 18 CONT Continue 50 50 Signal 50 19 STOP Stopped (signal) 51 51 Signal 51 20 TSTP Stopped 52 52 Signal 52 21 TTIN Stopped (tty input) 53 53 Signal 53 22 TTOU Stopped (tty output) 54 54 Signal 54 23 URG Urgent I/O condition 55 55 Signal 55 24 XCPU CPU time limit exceeded 56 56 Signal 56 25 XFSZ File size limit exceeded 57 57 Signal 57 26 VTALRM Virtual timer expired 58 58 Signal 58 27 PROF Profiling timer expired 59 59 Signal 59 28 WINCH Window size changed 60 60 Signal 60 29 IO I/O possible 61 61 Signal 61 30 PWR Power failure 62 62 Signal 62 31 SYS Bad system call 63 63 Signal 63 32 32 Signal 32 64 64 Signal 64 123456789101112131415161718下表列举了几个常见的信号量: |信号量|Value|描述||-----|-----|---||SIGABRT|6|通过C函数abort()发送；为assert()使用 ||SIGKILL|9|迅速完全终止进程；不能被捕获||SIGFPE|8|浮点数运算错误，如除0操作| |SIGSEGV|11|段地址错误，例如空指针、野指针、数组越界等||SIGPIPE|13|管道错误，例如向没有reader的管道中写,linux中socket断掉后继续写||SIGILL|4|非法指令，例如损坏的可执行文件或代码区损坏||SIGBUS|7|不存在的物理地址，更多为硬件或系统引起| (5) Call Stack信息 调用栈信息记录了程序在Crash前的函数调用关系以及正在执行函数的信息。#00，#01等为函数调用栈中栈帧的编号，编号越小的栈帧表示最近调用的函数信息，所以栈帧标号为#00 表示的是当前正在执行并导致程序crash的函数信息。pc后面的十六进制表示当前函数正在执行语句在共享链接库或可执行文件中的位置，/data/app/com.tencent.daemon-1/lib/arm/libhwnetcore.so表示执行指令在哪个文件中，括号里面注明了对应的函数。 backtrace: #00 pc 0007ebe0 /data/app/com.tencent.daemon-1/lib/arm/libhwnetcore.so (std::string::_M_assign(char const*, char const*)+7) #01 pc 001071d7 /data/app/com.tencent.daemon-1/lib/arm/libhwnetcore.so (Java_com_tencent_wechat_HWNetcore_addCommonRequest+30) #02 pc 001e0e79 /data/dalvik-cache/arm/data@app@com.tencent.daemon-1@base.apk@classes.dex 12345678910 ## 二、解析native crash堆栈的三种常用方法 为了能正确解析出来crash的堆栈，我们需要保存好obj下面的so,libs目录下的so丢失了调试信息和符号表，不能正确地解析出来原代码。 ### 1、使用ndk-stack ndk-stack命令从r6版本开始提供，能自动分析tombstone文件，将崩溃时的调用内存地址和c++代码一一对应，位于ndk目录下。 (1)直接利用adb logcat作为input adb logcat | $NDK/ndk-stack -sym $PROJECT_PATH/obj/local/armeabi 12345678910111213(2)解析文件 ``` adb logcat &gt; /tmp/foo.txt (可选，已经有crash file，直接解析即可) $NDK/ndk-stack -sym $PROJECT_PATH/obj/local/armeabi -dump foo.txt``` ### 2、使用arm-linux-androideabi-addr2line arm-linux-androideabi-addr2line和arm-linux-androideabi-objdump工具需要根据目标机器不同的CPU结构进行选择，位于ndk的交叉编译器工具链目录下。由于我们是Android平台，arm架构，选择arm-linux-androidabi-4.9下的工具即可，这两个工具均位于目录: $NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin 12 addr2line用于将地址转换为文件名称和行号，如果没有地址指定，将从stdin读取。通过addrline -h获得各个参数的含义: arm-linux-androideabi-addr2line -h The options are: @ Read options from -a --addresses Show addresses -b --target= Set the binary file format -e --exe= Set the input file name (default is a.out) -i --inlines Unwind inlined functions -j --section= Read section-relative offsets instead of addresses -p --pretty-print Make the output easier to read for humans -s --basenames Strip directory names -f --functions Show function names -C --demangle[=style] Demangle function names -h --help Display this information -v --version Display the program’s version 123456789101112一般用-C选项还原函数名称，-f选项展示函数名称，-e选项指定input file，使用范例如下,0x2c015d为令程序崩溃的汇编指令地址: ``` ./arm-linux-androideabi-addr2line -C -f -e /Users/lilycai/git_project/hardware_longlink/librarys/hw_longlink_prj/obj/local/armeabi/libhwnetcore.so 0x2c015d onStatisticsCallBack(StatisticsValue, std::string, std::string)/Users/lilycai/git_project/hardware_longlink/librarys/hw_longlink_prj/jni/Java2C.cpp:177 (discriminator 4)``` 如果不使用-C选项，得到的解析结果就是 _Z20onStatisticsCallBack15StatisticsValueSsSs /Users/lilycai/git_project/hardware_longlink/librarys/hw_longlink_prj/jni/Java2C.cpp:177 (discriminator 4) 1234### 3、使用arm-linux-androideabi-objdump arm-linux-androideabi-objdump与arm-linux-androideabi-addr2line位于同一目录下，用来从二进制文件中展示信息。使用objdump能够定位到出错的函数信息。使用方式为: ./arm-linux-androideabi-objdump &lt;option(s)&gt; &lt;file(s)&gt; 123456789101112131415161718192021222324252627282930313233343536可选参数为:``` At least one of the following switches must be given: -a, --archive-headers Display archive header information -f, --file-headers Display the contents of the overall file header -p, --private-headers Display object format specific file header contents -P, --private=OPT,OPT... Display object format specific contents -h, --[section-]headers Display the contents of the section headers -x, --all-headers Display the contents of all headers -d, --disassemble Display assembler contents of executable sections -D, --disassemble-all Display assembler contents of all sections -S, --source Intermix source code with disassembly -s, --full-contents Display the full contents of all sections requested -g, --debugging Display debug information in object file -e, --debugging-tags Display debug information using ctags style -G, --stabs Display (in raw form) any STABS info in the file -W[lLiaprmfFsoRt] or --dwarf[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames, =frames-interp,=str,=loc,=Ranges,=pubtypes, =gdb_index,=trace_info,=trace_abbrev,=trace_aranges, =addr,=cu_index] Display DWARF info in the file -t, --syms Display the contents of the symbol table(s) -T, --dynamic-syms Display the contents of the dynamic symbol table -r, --reloc Display the relocation entries in the file -R, --dynamic-reloc Display the dynamic relocation entries in the file @&lt;file&gt; Read options from &lt;file&gt; -v, --version Display this program&apos;s version number -i, --info List object formats and architectures supported -H, --help Display this information ``` 其中-d选项用于展示可执行部分的汇编程序内容,-D展示全部的汇编程序内容，-x选项用于显示所有header的内容，-S选项显示源代码。使用范例如下，使用的so为obj下面的so: ./arm-linux-androideabi-objdump -dx /Users/lily/prj/obj/local/armeabi/libhwnetcore.so &gt; /Users/lily/prj/obj/local/armeabi/dxobjdump.txt 12再看一下 0x2c015d这个地址，搜索2c015d，可以看到对应的函数为onStatisticsCallBack 002bffe4 &lt;_Z20onStatisticsCallBack15StatisticsValueSsSs&gt;: … 2c015c: f043 fa92 bl 303684 &lt;__aeabi_llsl+0x2231c&gt; … 12使用-S -D耗时会多一些: ./arm-linux-androideabi-objdump -S -D /Users/lily/prj/obj/local/armeabi/libhwnetcore.so &gt; /Users/lily/prj/obj/local/armeabi/SDobjdump.txt 1234567## 附录 从ndk r11开始，Android NDK已经废弃了gcc，Android默认使用clang/llvm, gcc只支持到4.9，但由于google的libc++库还不完善，所以gcc还会继续保留一段时间。 要想使用ndk-build命令或NDK，需要安装 GNU Make 3.81 或更新版本，通过下列命令可以看到GNU Make 3.81已安装。 gnumake --version GNU Make 3.81 Copyright © 2006 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. This program built for i386-apple-darwin11.3.0 1234567### 1、ndk-build 常用参数 ndk-build 文件是 Android NDK r4 中引入的一个 shell 脚本。其用途是调用正确的 NDK 构建脚本。可通过内部构建和从命令行调用两种方式使用ndk-build。 (1)内部构建 运行 ndk-build 脚本相当于运行以下命令： $GNUMAKE -f /build/core/build-local.mk 1234$GNUMAKE 指向 GNU Make 3.81 或更新版本，&lt;ndk&gt; 指向 NDK 安装目录。 可以使用此信息从其他 shell 脚本甚至自己的 Make 文件调用 ndk-build。 范例: 我的ndk目录位于/Users/lilycai/Library/Android/sdk/ndk-bundle/,进入到proj目录后，调用如下命令即可进行编译 gnumake -f /Users/lilycai/Library/Android/sdk/ndk-bundle/build/core/build-local.mk 1234(2)使用命令行 ndk-build 的所有参数将直接传递到运行 NDK 构建脚本的底层 GNU make。 ndk-build clean 移除之前生成的任意二进制文件 V=1 启动构建，并显示构建命令 -B 强制执行完全的重新构建 NDK_DEBUG=1 强制执行可调试版构建(这个参数很有用，启用这个参数obj下可保留符号表) NDK_DEBUG=0 强制执行发布 NDK_HOST_32BIT = 1 始终使用32位模式下的工具链(针对某些附带64和32位两个版本的工具链，64位的工具速度更快，能处理更大的程序，更好地利用主机资源) -C 构建位于的项目路径的原生代码(可不cd切换到项目路径) -jX X为线程数，ndk-build默认为单线程编译，一般为CPU核数-1 1234 ### 2、指定编译的toolchain 在Application.mk中添加 NDK_TOOLCHAIN_VERSION = 4.9 12 未指定工具链之前，使用ndk默认的工具链，编译log如下所示 /Users/lilycai/Library/Android/sdk/ndk-bundle/ndk-build -j8 NDK_DEBUG=1 [armeabi] Compile++ thumb: hwnetcore &lt;= Java2C.cpp [armeabi] Compile++ thumb: hwnetcore &lt;= CallStack.cpp [armeabi] Compile++ thumb: hwnetcore &lt;= Java2C_LogLogic.cpp [armeabi] Compile++ thumb: hwnetcore &lt;= Java2C_Xlog.cpp [armeabi] Prebuilt : libstlport_shared.so &lt;= /sources/cxx-stl/stlport/libs/armeabi/ [armeabi] Gdbserver : [arm-linux-androideabi] libs/armeabi/gdbserver [armeabi] Gdbsetup : libs/armeabi/gdb.setup 12指定了4.9的工具链以后，编译log如下所示，可以清楚地看到使用的工具链 ndk-build -j4 NDK_DEBUG=1 [armeabi] Compile++ thumb: hwnetcore &lt;= Java2C.cpp [armeabi] Compile++ thumb: hwnetcore &lt;= CallStack.cpp [armeabi] Compile++ thumb: hwnetcore &lt;= Java2C_LogLogic.cpp [armeabi] Compile++ thumb: hwnetcore &lt;= Java2C_Xlog.cpp [armeabi] Prebuilt : libstlport_shared.so &lt;= /sources/cxx-stl/stlport/libs/armeabi/ [armeabi] Gdbserver : [arm-linux-androideabi-4.9] libs/armeabi/gdbserver [armeabi] Gdbsetup : libs/armeabi/gdb.setup 1234### 3、与NDK_DEBUG = 1相同效果的debug编译选项 在Application.mk中进行配置 APP_OPTIM := debug 参考文献: 1、[google官方ndk-build](https://developer.android.google.cn/ndk/guides/ndk-build.html?hl=zh-cn) 2、[google官方ndk-stack](https://developer.android.com/ndk/guides/ndk-stack.html) 3、[Android 开发中常见 Crash 的情况](https://www.geekhub.cn/a/294.html) 4、[ABI百度百科](https://baike.baidu.com/item/ABI/10912305#viewPageContent) 5、[Android平台Native代码的崩溃捕获机制及实现](http://km.oa.com/group/18954/articles/show/307888)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[adb实用命令小结]]></title>
      <url>%2F2017%2F04%2F18%2Fadb%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[adb对于Android程序员来说在日常的工作中使用频率很高，现将自己工作中常用的adb命令总结一下备忘，方便查询，也供大家参考。查看应用内存占用，耗电信息，启动时间，wakelock，跑monkey的命令在之前的应用性能优化中起了不小的作用。以下adb命令的测试机器为小米3,其中package_name代表包名。 ¶基础脚本: 1、启动adb服务 1adb start-server 2、终止adb服务 1adb kill-server 3、进入adb运行环境 1adb shell 4、获取帮助 里面有adb的各种命令和参数的介绍 1adb help 5、查看adb版本 1adb version 6、以root权限重启adb 1adb root 7、将system分区重新挂在为可读写分区，此命令在操作系统目录时很重要 1adb remount 8、重启设备,可选参数进入bootloader(刷机模式)或recovery(恢复模式) 1adb reboot [bootloader|recovery] ¶apk相关: 1、安装apk 1234adb install test.apk -r 覆盖安装，保留数据和缓存文件 -d 解决低版本version问题 -s 安装apk到sd卡 2、卸载apk 1adb uninstall -k &lt;package_name&gt; 可选参数-k的作用为卸载软件但是保留配置和缓存文件 3、查看app相关所有信息，包括action,codepath,version,需要的权限等等信息 1adb shell dumpsys package &lt;package_name&gt; 4、查看app的路径 1adb shell pm path &lt;package_name&gt; 查看了一个普通app的路径，如下，位于data/app下面的普通app package:/data/app/com.tencent.test-1/base.apk 5、查看apk的版本信息 1adb shell dumpsys package &lt;package_name&gt; | grep version 如果你得到的是下图的两个version版本，则为系统app,下面是系统app本身的版本，上面是升级之后的系统app的版本信息 1234versionCode=8 targetSdk=22 versionName=V0.08versionCode=6 targetSdk=22 versionName=V0.0 6、启动activity 1adb shell am start -n &lt;package_name&gt;/.&lt;activity_class_name&gt; 7、获得应用的启动时间，可以很方便地获取应用的启动时间 1adb shell am start -W &lt;package_name&gt;/.&lt;activity_class_name&gt; 试验结果如下: 12345678adb shell am start -W com.cc.test/com.painter.test.PainterMainActivityStarting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.cc.test/com.painter.test.PainterMainActivity &#125;Status: okActivity: com.cc.test/com.painter.test.PainterMainActivityThisTime: 355TotalTime: 355WaitTime: 365Complete 返回的几个结果，以WaitTime为准，返回的是从startActivity到应用第一帧完全显示的时间。 8、启动service,am的-n参数表示组件，-a参数表示命令，-a后面的参数为manifest中定义的service的action 1adb shell am startservice -n &lt;package_name&gt;/.&lt;service_class_name&gt; 也可: 1adb shell am startservice -a &quot;android.intent.action.CALL&quot; 9、发送广播 1adb shell am broadcast -a &quot;android.intent.action.AdupsFota.WriteCommandReceiver&quot; 广播可以带上不同类型的参数,–es为string参数类型,–ei为int参数类型,–ez为boolean参数类型 1adb shell am broadcast -a &quot;android.intent.action.AdupsFota.WriteCommandReceiver&quot; --es test_string &quot;this is test string&quot; 10、查看某个app的进程相关信息 10.1 1adb shell ps &lt;package_name|PID&gt; 例如 1234adb shell ps com.ma.app:pushUSER PID PPID VSIZE RSS WCHAN PC NAMEu0_a116 5483 304 1776564 55112 sys_epoll_ 00000000 S com.ma.app:push 小米手机上测试成功，在另外一个设备上，如果ps后面的参数是包名则显示不了进程的详细信息，参见下面的方式获取 10.2 1adb shell ps | grep &lt;package_name&gt; 11、杀掉某个进程，一般用于模拟某个bug复现 1adb shell kill pidNumber 12、查看某一个app的内存占用 1adb shell dumpsys meminfo &lt;package_name|PID&gt; 结果如下，其中的Heap size包括了Dalvik Heap和Native Heap,平时我们所说的内存限制指的是Dalvik Heap。 1234567891011121314151617 Pss Private Private Swapped Heap Heap Heap Total Dirty Clean Dirty Size Alloc Free ------ ------ ------ ------ ------ ------ ------ Native Heap 18956 18940 0 4696 44288 21352 22935 Dalvik Heap 60102 60088 0 26192 104486 88285 16201 App Summary Pss(KB) ------ Java Heap: 61640 Native Heap: 18940 Code: 3356 Stack: 428 Graphics: 16876 Private Other: 3840 System: 2031... 13、查看单个应用程序的最大内存限制 1adb shell getprop | grep heapgrowthlimit 得到的结果为128M: [dalvik.vm.heapgrowthlimit]: [128m] 这就是说Dalvik Heap size的最大值超过了128M，就很可能发生OOM 14、获取单个应用的电量消耗信息 Battery Historian是Android 5.0开始引入的，下面的命令为获取单个app的电量消耗信息，获取系统耗电信息见下节 1adb shell dumpsys batterystats &gt; &lt;package_name&gt; &gt; xxx.txt 上面的电量信息为原始数据，可以通过google编写的historian.py脚本把数据信息转换为可读性很好的html文件,类似TraceView生成的列表数据，之前在做app性能优化的时候起了很大的作用 1python historian.py xxx.txt &gt; xxx.html 15、跑monkey,个人很喜欢这个命令，运行过程中，应用程序会不断切换画面，按照选定的不同级别反馈信息，还可以看到执行过程报告和生成的事件。测试应用的稳定性时很实用。 现在studio也有了monkeyrunner的tool 123adb shell monkey -v -p &lt;package_name&gt; 500 -p 对象包 -v 反馈信息级别 12345:Monkey: seed=1493061025112 count=500:AllowPackage: com.tencent.mm.app:push:IncludeCategory: android.intent.category.LAUNCHER:IncludeCategory: android.intent.category.MONKEY** No activities found to run, monkey aborted. ¶系统相关 1、查看设备名称，豌豆荚等应用就是通过此来获得设备的名称 1adb shell cat /system/build.prop/ 结果: 12ro.product.model=MI 3Wro.product.brand=Xiaomi 2、查看手机分辨率有两种方法，第二种方法最为简洁 2.1 1adb shell dumpsys window | grep Surface grep是一个非常有用的参数,具体含义和用法大家自行google一下,试验结果为1080 * 1920: 1Surface: shown=false layer=21000 alpha=1.0 rect=(0.0,0.0) 1080.0 x 1920.0 2.2. 1adb shell wm size 返回结果为: 1Physical size: 1080x1920 3、查看手机sdk版本 1adb shell getprop | grep version 运行上面的命令后，列出来的version中[ro.build.version.release]: [6.0.1]即为手机sdk版本 4、查看手机型号信息 1adb shell getprop | grep product 运行此命令之后，能看到product,board,brand和cpu等等的型号 5、获取序列号，获取到的序列号即为adb devices列出来的序列号 1adb get-serialno 6、查看连接的设备 1adb devices 如果有多个设备连接，想对其中的某一设备进行操作，就需要在此命令的后面加参数 1234567adb [-d|-e|-s &lt;serial Number&gt;] &lt;command&gt; -d:真机(多个设备中只有一个真机时适用) -e:模拟器(多个设备中只有一个模拟器时适用) -s:序列号 假如有两个真机连接了我的电脑，adb devices获取到的数据如下 123List of devices attached1b71651 device12sdfsd device 进入1b71651设备的命令为: 1adb -s 1b71651 shell 7、查看wifi密码(需要root权限) 1adb shell cat data/misc/wifi/*.conf 8、查看wifi_mac 1adb shell cat /sys/class/net/wlan0/address 运行此命令，93:a1:a2:91:d1:c1是小米3的wifi_mac地址 9、查看后台services信息 1adb shell service list 运行结果为 1234Found 126 services:0 miui.whetstone.net: [miui.whetstone.INetworkService]1 miui.whetstone.power: [miui.whetstone.power]... 10、查看系统当前内存占用，为综述 1adb shell cat /proc/meminfo 运行结果: 12345678MemTotal: 1893504 kBMemFree: 81200 kBBuffers: 14828 kBCached: 244152 kBSwapCached: 15152 kBActive: 541680 kBInactive: 575280 kB... 11、查看各进程详细内存占用和系统的内存占用有几种方法 11.1 1adb shell dumpsys meminfo 12345Total PSS SWAP by process: 97858 kB: 34944 kB: com.android.systemui (pid 2769) ...Total RAM: 1893504 kB (status normal)Free RAM: 344212 kB (117992 cached pss + 136016 cached kernel + 90204 free) Total PSS 信息就是你的应用真正占据的内存大小，通过这个信息，可以轻松判别手机中哪些程序占内存比较大。 11.2 查看各进程内存的另一方法 不是所有设备都支持 1adb shell procrank 运行结果如下: 12345678PID Vss Rss Pss Uss cmdline 496 1810184K 92744K 57607K 48348K system_server 743 1847492K 84492K 52117K 46796K com.android.systemui .... ------ ------ ------ 328259K 261484K TOTALRAM: 2061012K total, 889152K free, 40940K buffers, 612032K cached, 300K shmem, 62556K slab 其中 1234VSS – Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）RSS – Resident Set Size 实际使用物理内存（包含共享库占用的内存）PSS – Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）USS – Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存） 11.3 查看设备上进程的cpu和内存占用情况 1adb shell top 12、查看系统耗电情况 1adb shell dumpsys batterystats &gt; xxx.txt 13、查看系统设置的闹钟 1adb shell dumpsys alarm 14、查看系统的wakelock,不合理的使用wakelock会导致系统耗电加剧 1adb shell dumpsys power 返回结果: 123Wake Locks: size=2 PARTIAL_WAKE_LOCK &apos;AudioMix&apos; (uid=1013, pid=236, ws=WorkSource&#123;10018&#125;) PARTIAL_WAKE_LOCK &apos;Android.media.MediaPlayer&apos; ON_AFTER_RELEASE (uid=10018, pid=24023, ws=null) 15、系统时间相关 15.1 获取系统时间 12adb shell dateThu May 4 20:34:29 CST 2017 15.2 修改系统时间(需要root权限) 12adb rootadb date -s &quot;yyyymmdd.[[[hh]mm]ss]&quot; 上面的参数看起来有点复杂，其实就是除了年月日之外，只有两个参数代表的是秒,再加两个参数代码的是分钟，再加两个参数是小时。 例: 12adb shell date -s &quot;20170504.03&quot;Thu May 4 00:00:03 CST 2017 12adb shell date -s &quot;20170504.0330&quot;Thu May 4 00:03:30 CST 2017 ¶文件操作相关: 1、拷贝文件/目录到设备 1adb push &lt;local&gt;...&lt;remote&gt; 2、从设备拷贝文件/目录，-a参数保留了文件的时间戳和模式 1adb pull [-a] &lt;remote&gt;...&lt;local&gt; 3、查看设备log,和studio和eclipse的logcat相同，可通过参数控制输出的日志 12345adb logcat -s 过滤指定参数log -v time 保留日志时间 &gt;&gt; 追加写 &gt; 覆盖写 下面的命令含义为:打印出log信息中的时间并且包含关键字 “Test” 的所有log以覆盖写的方式保存到test文件 1adb logcat -v time -s Test &gt; test.txt 4、列出目录下的文件和文件夹，可选参数-al可查看文件和文件夹的详细信息 1adb shell ls [-al] 5、进入文件夹 1adb shell cd &lt;folder&gt; 6、查看文件 1adb shell cat &lt;filename&gt; 7、重命名文件 1adb shell rename path/oldfilename path/newfilename 8、删除文件/文件夹 12adb shell rm path/filename -r 可选参数用于删除文件夹及下面的所有文件 eg:adb shell rm -r &lt;folder&gt; 9、移动文件 1adb shell mv path/filename newpath/filename 10、拷贝文件 1adb shell cp file newpath/file1 11、创建目录 1adb shell mkdir path/folder 12、设置文件最高读写权限 1adb shell chmod 777 filename 13、手机未root 查看data/data/某一app文件信息 笔者的小米3没有root，但是又想方便地查看data/data/目录下的一些文件，直接进入data会提示没有权限,查看的方式为进入data/data/后,运行下面的命令，就能直接进入你应用的包下了,可通用cp或者mv拷贝或移动到sdcard目录进行其他操作 1run-as package_name ¶数据库相关 数据库的操作和今天的主题关系不大，增删改查操作不再列举。但是平时的开发过程中只是查看数据库中某个表或者某个字段，也无需每次都pull出来之后再查看，用命令行会更加方便快捷,进入到test.db的目录后，运行如下命令 1、操作db 1sqlite3 test.db 2、对db使用sqlite3命令后，通过.help查看各种使用指导 1.help 3、列举数据库的table名称 1.tables 4、列表数据库的schema，个人觉得下面两个命令很有用，效果等同，可以方便快捷地查看数据库字段对应的数据类型，.schema更加简洁 1.schema 或者 1select * from sqlite_master where type = &quot;table&quot;; ps:原创文章，转载注明出处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[硬装-水路改造前你需要知道的事]]></title>
      <url>%2F2017%2F03%2F26%2F%E7%A1%AC%E8%A3%85-%E6%B0%B4%E8%B7%AF%E6%94%B9%E9%80%A0%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[¶硬装的水路改造有很大的学问，需要提前做好功课。 硬装前无论是新房还是二手房，尤其是二手房翻新，装修前都需要先做闭水测试，装修后出现漏水很麻烦，叫上物业一起进行，确保装修前无问题，有问题马上让物业负责解决;根据各地的水质情况，看是否需要安装入户过滤器，和物业确认入户过滤器是否可放置在楼道，如果不可以，可放在家庭用水总入口处 日常家庭用水很多需要冷热同用，比如热水器、洗碗池、洗手池等。水管的冷热要分离，为了便于日后检查和维修区分，可通过对冷热水管路进行分色套管处理，所有的热水管均为红色，冷水均为蓝色。如果难以分色，也可以按照方向区分，如左边热水，右边冷水 水管的材料，一些老式住宅中还是镀锌管，长期使用后容易产生锈蚀，造成水中重金属含量过高，严重危害人体健康；含铅的PVC管也同样因危害健康被禁止。并非所有的水管都是冷热两用的，一般的PPR管、PE管、铜管都是冷热两用的。PVC管不能用于热水，因此常用于下水道。 水路改造时，管线和接头必须是垂直相接的,否则会造成弯头连接的两遍管线壁厚不一样，使用中可能会因为受力不均匀，在水压下出现渗漏。尤其是靠近电路的水管，防漏和密封性必须保证，否则万一漏水，会引发触电，十分危险。 水路改造常用尺寸 淋浴：冷热水管中心间距150mm，距地1000-1200mm 上翻盖洗衣机：水口高度1200mm 电热水器：给水口高度=层净高-电热水器固定上方距顶距离-电热水器直径-200mm 水盆、菜盆：给水口高度450-550mm 马桶：给水口距地200mm，距马桶中心一般靠左250mm 墩布池：给水口高出池本身200mm为宜 水路改造-验收 打压测试，并非越高越好 水路改造完成后，为了避免漏水，必须进行打压测试。许多业主认为打压越高越好，这样可以测出水管和水路的承受能力,其实并不是打压越高越好，打压压力太高可能会超出水管的承压极限，反而会损伤管道，减少寿命，导致以后出现漏水。正常压力测试在6-8kg为最佳，实验压力不应该小于0.6mpa，时间为20-30分钟。 多次打压测试，效果才好。水路测试并非只有一次，正确的试水方法是：试压前关闭水电阀门，进行室内管路系统打压；将试压管道末端封堵慢慢注水，将管道内气体排出，充满水后进行密封检查；加压采用手动泵或者电动泵缓慢升压，升至规定试验压力后，停止加压，观察接头部位是否有渗水现象；稳压后，半小时内的压力降不超过0.05MPa为合格。 绘制水路图，维修有保障。做到水路改造的房子最好能重新绘制水路图，因为施工时，很多时间由于各种原因无法按照设计图100%实施，所以必须按照实际水路重新制图，以免给日后维修增加难度。 ¶参考: 妈妈网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[硬装-插座篇]]></title>
      <url>%2F2017%2F03%2F26%2F%E7%A1%AC%E8%A3%85-%E6%8F%92%E5%BA%A7%E4%B8%93%E9%A1%B9%E7%AF%87%2F</url>
      <content type="text"><![CDATA[插座的预留原则是：宁多勿少，免得添加电器时遇到插座不够用的尴尬。 插座规划需要注意的问题以下几点： 插座不够用，满地都是排插线 开关被家具挡住，或者太高太低 没留双控开关 根据我家户型的实际情况设计了开关和插座的数量,仅作为各位的参考，实际情况还要根据实际户型情况来做调整。 ¶玄关 插座:预留一个 开关:与客厅开关处做双控 ¶客厅 插座: 电视两个(包括电视机和机顶盒) 空调一个 沙发两侧各一个(因户型而异，我家的户型要一侧留2个) 预留1-2个 开关: 吊灯双回路控制 玄关灯双控 装饰效果灯开关 ¶餐厅 插座： 餐桌边2个 预留1-2个 开关： 吊灯双回路控制 装饰效果灯 ¶厨房 插座: 抽油烟机1个(3孔带开关) 炉灶下1个 水槽下1个(广州水质比较差，除了在总入水口安装入户过滤器之外，需要在水槽下安装净水器) 水台边1个 操作台2-3个 电冰箱(3孔带开关) 微波炉、烤箱、洗碗机、洗菜机等电器按需添加插座和开关 开关: 吸顶灯 操作台灯 ¶洗手间 插座: 吹风机1个(3孔带开关或普通插座无开关) 电热水器1个(3孔带开关) 浴霸 预留1-2个 开关: 镜前灯 排风扇 浴霸 吸顶灯 ¶卧室 插座: 床头两边各1个;预留1-2个 电视2个 空调1个 电脑1个(带网线[根据实际需求]) 开关: 双控或双回路控制(需控制家里所有的灯) 位于床头，方便控制 吸顶灯 装饰效果灯 根据我家的实际情况，次卧需要为孩子的电脑、台灯预留插座。 ¶书房 插座: 电脑1个(3孔带开关) 空调1个(3孔带开关) 书桌1个 预留1-2个 开关: 吸顶灯 电脑电视共享 ¶阳台 插座: 洗衣机 开关: 顶灯 ¶插座的推荐安装位置 ¶市面上不错的插座位置 ¶参考: 妈妈网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F19%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ¶Quick Start ¶Create a new post 1$ hexo new "My New Post" More info: Writing ¶Run server 1$ hexo server More info: Server ¶Generate static files 1$ hexo generate More info: Generating ¶Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
